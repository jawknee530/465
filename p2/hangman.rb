#!/usr/bin/env ruby
#Jon Allen
#CSCI 465
#Demonstration of spaghetti code generated by waiting 
#too long to start an assignment

$chances = 10
$ended = false
$empty = false
$target = "0"
$uptarget = "0"
$letters = []

puts "Enter word length between 5 and 20: "
length = gets.to_i
if length < 5 then length = 5 end
if length > 20 then length = 20 end

for i in 0..length-1
  $letters[i] = '_'
end


words = IO.read("words").split("\n")
words.keep_if {|x| x.length == length}

$guesses = Array.new

def take_guess(letter)
  if letter.length > 1 then
    puts "Enter a single character, try again: "
    return false
  elsif $guesses.include?(letter) || $guesses.include?(letter.upcase) || $guesses.include?(letter.downcase) then
    puts "Already guessed that letter, try again: "
    return false
  else
    $guesses.push(letter)
    $guesses.push(letter.upcase)
    $guesses.push(letter.downcase)
    $chances = $chances-1
    if $chances == 0 then
      $ended = true
      return false
    end
    return true
  end
end

def check_words(letter, words2)
  temp = []
  temp = words2.map do |x| x.dup end
  words2.map! {|x| if x =~ /#{letter}/ then nil else x end}.compact!
  if words2.any? then
    $empty = false 
    return words2
  else
    $empty = true
    return temp
  end
end

def print_results(length)
  puts "Current Results"
  for i in 0..length-1
    if $guesses.include?($target[i]) or $guesses.include?($uptarget[i]) then
      puts $target[i]
    else
      puts "_"
    end
  end
  puts "Guesses left: #{$chances}"
end

while !($ended) do
  puts "enter your guess: "
  guess = gets.chomp
  if take_guess(guess) then
    if $target == "0" then
      temp = []
      temp = check_words(guess, words)
      if $empty then
        words = temp.map do |x| x.dup end
        $target = words[0]
        $uptarget = words[0].upcase
        puts $uptarget
        $uptarget = $uptarget.split(//)
        $target = $target.split(//)
      end
    end
  end
  print_results(length)

end

